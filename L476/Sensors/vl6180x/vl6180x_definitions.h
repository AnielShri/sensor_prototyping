/*
 * vl6180x_definitions.h
 *
 *  Created on: Nov 30, 2023
 *      Author: Aniel
 */

#ifndef VL6180X_VL6180X_DEFINITIONS_H_
#define VL6180X_VL6180X_DEFINITIONS_H_

//=============================================================================
//	generic error
//=============================================================================
#define  VL6180X_GENERIC_ERROR (0xFF)

//=============================================================================
//	I2C device addresses
//=============================================================================

#define VL6180X_I2C_DEVICE_ADDRESS	(0x29 << 1)

//=============================================================================
//	Internal register addresses
//=============================================================================
typedef enum
{
	VL6180X_REGISTER_IDENTIFICATION_MODEL_ID         = 0x000,
	VL6180X_REGISTER_IDENTIFICATION_MODEL_REV_MAJOR  = 0x001,
	VL6180X_REGISTER_IDENTIFICATION_MODEL_REV_MINOR  = 0x002,
	VL6180X_REGISTER_IDENTIFICATION_MODULE_REV_MAJOR = 0x003,
	VL6180X_REGISTER_IDENTIFICATION_MODULE_REV_MINOR = 0x004,
	VL6180X_REGISTER_IDENTIFICATION_DATE_HI          = 0x006,
	VL6180X_REGISTER_IDENTIFICATION_DATE_LO          = 0x007,
	VL6180X_REGISTER_IDENTIFICATION_TIME             = 0x008,

	VL6180X_REGISTER_SYSTEM_MODE_GPIO0             = 0x010,
	VL6180X_REGISTER_SYSTEM_MODE_GPIO1             = 0x011,
	VL6180X_REGISTER_SYSTEM_HISTORY_CTRL           = 0x012,
	VL6180X_REGISTER_SYSTEM_INTERRUPT_CONFIG_GPIO  = 0x014,
	VL6180X_REGISTER_SYSTEM_INTERRUPT_CLEAR        = 0x015,
	VL6180X_REGISTER_SYSTEM_FRESH_OUT_OF_RESET     = 0x016,
	VL6180X_REGISTER_SYSTEM_GROUPED_PARAMETER_HOLD = 0x017,

	VL6180X_REGISTER_SYSRANGE_START                       = 0x018,
	VL6180X_REGISTER_SYSRANGE_THRESH_HIGH                 = 0x019,
	VL6180X_REGISTER_SYSRANGE_THRESH_LOW                  = 0x01A,
	VL6180X_REGISTER_SYSRANGE_INTERMEASUREMENT_PERIOD     = 0x01B,
	VL6180X_REGISTER_SYSRANGE_MAX_CONVERGENCE_TIME        = 0x01C,
	VL6180X_REGISTER_SYSRANGE_CROSSTALK_COMPENSATION_RATE = 0x01E,
	VL6180X_REGISTER_SYSRANGE_CROSSTALK_VALID_HEIGHT      = 0x021,
	VL6180X_REGISTER_SYSRANGE_EARLY_CONVERGENCE_ESTIMATE  = 0x022,
	VL6180X_REGISTER_SYSRANGE_PART_TO_PART_RANGE_OFFSET   = 0x024,
	VL6180X_REGISTER_SYSRANGE_RANGE_IGNORE_VALID_HEIGHT   = 0x025,
	VL6180X_REGISTER_SYSRANGE_RANGE_IGNORE_THRESHOLD      = 0x026,
	VL6180X_REGISTER_SYSRANGE_MAX_AMBIENT_LEVEL_MULT      = 0x02C,
	VL6180X_REGISTER_SYSRANGE_RANGE_CHECK_ENABLES         = 0x02D,
	VL6180X_REGISTER_SYSRANGE_VHV_RECALIBRATE             = 0x02E,
	VL6180X_REGISTER_SYSRANGE_VHV_REPEAT_RATE             = 0x031,

	VL6180X_REGISTER_SYSALS_START                   = 0x038,
	VL6180X_REGISTER_SYSALS_THRESH_HIGH             = 0x03A,
	VL6180X_REGISTER_SYSALS_THRESH_LOW              = 0x03C,
	VL6180X_REGISTER_SYSALS_INTERMEASUREMENT_PERIOD = 0x03E,
	VL6180X_REGISTER_SYSALS_ANALOGUE_GAIN           = 0x03F,
	VL6180X_REGISTER_SYSALS_INTEGRATION_PERIOD      = 0x040,

	VL6180X_REGISTER_RESULT_RANGE_STATUS          = 0x04D,
	VL6180X_REGISTER_RESULT_ALS_STATUS            = 0x04E,
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO = 0x04F,
	VL6180X_REGISTER_RESULT_ALS_VAL               = 0x050,

	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_0 = 0x052,
	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_1 = 0x054,
	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_2 = 0x056,
	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_3 = 0x058,
	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_4 = 0x05A,
	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_5 = 0x05C,
	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_6 = 0x05E,
	VL6180X_REGISTER_RESULT_HISTORY_BUFFER_7 = 0x060,

	VL6180X_REGISTER_RESULT_RANGE_VAL                    = 0x062,
	VL6180X_REGISTER_RESULT_RANGE_RAW                    = 0x064,
	VL6180X_REGISTER_RESULT_RANGE_RETURN_RATE            = 0x066,
	VL6180X_REGISTER_RESULT_RANGE_REFERENCE_RATE         = 0x068,
	VL6180X_REGISTER_RESULT_RANGE_RETURN_SIGNAL_COUNT    = 0x06C,
	VL6180X_REGISTER_RESULT_RANGE_REFERENCE_SIGNAL_COUNT = 0x070,
	VL6180X_REGISTER_RESULT_RANGE_RETURN_AMB_COUNT       = 0x074,
	VL6180X_REGISTER_RESULT_RANGE_REFERENCE_AMB_COUNT    = 0x078,
	VL6180X_REGISTER_RESULT_RANGE_RETURN_CONV_TIME       = 0x07C,
	VL6180X_REGISTER_RESULT_RANGE_REFERENCE_CONV_TIME    = 0x080,
	VL6180X_REGISTER_READOUT_AVERAGING_SAMPLE_PERIOD     = 0x10A,

	VL6180X_REGISTER_FIRMWARE_BOOTUP        = 0x119,
	VL6180X_REGISTER_FIRMWARE_RESULT_SCALER = 0x120,

	VL6180X_REGISTER_I2C_SLAVE_DEVICE_ADDRESS = 0x212,
	VL6180X_REGISTER_INTERLEAVED_MODE_ENABLE  = 0x2A3,

}vl6180x_register_address_enum;


//=============================================================================
//	identification values
//=============================================================================
#define VL6180X_REGISTER_IDENTIFICATION_MODEL_ID_VALUE (0xB4)


//=============================================================================
//	VL6180X_REGISTER_SYSRANGE_START
//=============================================================================
#define VL6180X_REGISTER_SYSRANGE_START_VALUE_DISABLE                (0b00)
#define VL6180X_REGISTER_SYSRANGE_START_VALUE_SINGLE_SHOT            (0b01)

// According to VL6180X datasheet:
// bit 0 => Setting this bit to 1 in continuous mode will either start (if stopped) or halt (if started) continuous operation
//			This bit is auto-cleared in both modes of operation.
// bit 1 => 1: Ranging Mode Continuous
#define VL6180X_REGISTER_SYSRANGE_START_VALUE_TOGGLE_CONTINUOUS_MODE (0b11)

// AN4545, chapter 2.1 suggests to write 0x01 instead of using the toggle functionality
// this is most likely to explicitly disable continuous mode instead of accidentally starting it
#define VL6180X_REGISTER_SYSRANGE_START_VALUE_STOP_CONTINUOUS_MODE 	 (0b01)


//=============================================================================
//	VL6180X_REGISTER_SYSTEM_INTERRUPT_CLEAR
//=============================================================================
typedef enum
{
	VL6180X_REGISTER_SYSTEM_INTERRUPT_CLEAR_VALUE_RANGE = 0b001,
	VL6180X_REGISTER_SYSTEM_INTERRUPT_CLEAR_VALUE_ALS   = 0b010,
	VL6180X_REGISTER_SYSTEM_INTERRUPT_CLEAR_VALUE_ERROR = 0b100,
	VL6180X_REGISTER_SYSTEM_INTERRUPT_CLEAR_VALUE_ALL   = 0b111,
}vl6180x_int_clear_sig_enum;


//=============================================================================
//	VL6180X_REGISTER_RESULT_RANGE_STATUS
//=============================================================================

#define VL6180X_REGISTER_RESULT_RANGE_STATUS_MASK_DEVICE_READY 		  (0b00000001)
#define VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_DEVICE_READY_FALSE (0b0)
#define VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_DEVICE_READY_TRUE  (0b1)

typedef enum
{
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_NO_ERROR                   = (0b0000 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_VCSEL_CONTINUITY_TEST      = (0b0001 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_VCSEL_WATCHDOG_TEST        = (0b0010 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_VCSEL_WATCHDOG             = (0b0011 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_PLL1_LOCK                  = (0b0100 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_PLL2_LOCK                  = (0b0101 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_EARLY_CONVERGENCE_ESTIMATE = (0b0110 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_MAX_CONVERGENCE            = (0b0111 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_NO_TARGET_IGNORE           = (0b1000 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_Max_SNR                    = (0b1011 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_Raw_Ranging_Algo_Underflow = (0b1100 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_Raw_Ranging_Algo_Overflow  = (0b1101 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_Ranging_Algo_Underflow     = (0b1110 << 3),
	VL6180X_REGISTER_RESULT_RANGE_STATUS_VALUE_ERROR_Ranging_Algo_Overflow      = (0b1111 << 3),
}vl6180x_result_range_error_code_enum;

#define VL6180X_REGISTER_RESULT_RANGE_STATUS_MASK_ERROR_CODE (0b11110000)

//=============================================================================
//	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO
//=============================================================================
typedef enum
{
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_RANGE_NO_EVENTS               = 0b000,
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_RANGE_LOW_LEVEL_THRESHOLD     = 0b001,
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_RANGE_HIGH_LEVEL_THRESHOLD    = 0b010,
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_RANGE_OUT_OF_WINDOW_THRESHOLD = 0b011,
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_RANGE_NEW_SAMPLE_READY        = 0b100,
}vl6180x_result_int_range_gpio_enum;
#define VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_MASK_RANGE (0b00000111)

typedef enum
{
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ALS_NO_EVENTS               = (0b000 << 2),
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ALS_LOW_LEVEL_THRESHOLD     = (0b001 << 2),
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ALS_HIGH_LEVEL_THRESHOLD    = (0b010 << 2),
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ALS_OUT_OF_WINDOW_THRESHOLD = (0b011 << 2),
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ALS_NEW_SAMPLE_READY        = (0b100 << 2),
}vl6180x_result_int_als_gpio_enum;
#define VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_MASK_ALS (0b00111000)

typedef enum
{
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ERROR_NO_ERROR           = (0b00 << 5),
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ERROR_LASER_SAFETY_ERROR = (0b01 << 5),
	VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_VALUE_ERROR_PLL_ERROR          = (0b00 << 5),
}vl6180x_result_int_error_gpio_enum;
#define VL6180X_REGISTER_RESULT_INTERRUPT_STATUS_GPIO_MASK_ERROR (0b11000000)


#endif /* VL6180X_VL6180X_DEFINITIONS_H_ */
